### MVC、MVP、MVVM的区别

MVC是一个比较宽泛的架构概念，主要就是划分出Model、View、Controler三层结构，Model层用于管理数据、View层用于控制视图也就是xml，Controler用于逻辑控制， 在Android中由Activiy或Fragment来进行，但由于Activity也会做更新视图的工作。就会导致View层与Model层的耦合 。

主流的MVP观点是从Activity中抽出一个Presenter，这个Presenter他负责真正的Controler功能。Presenter创建Model实例获取数据，并通过持有的Activity实例来更新页面，Presenter只负责通知，具体操作由Model与View层实现。

关于他们的区别，实际上MVP与MVC的联系是很紧密的，本质上并没有太大区别，MVP实际上把MVP的Presenter改成Controler是没问题的，Android中的MVC，Activiy既做页面又做逻辑控制，实际上应该叫M-VC，他们的V层和C层是耦合在一起的，他们是两块的逻辑而非三块的逻辑。

关于MVVM实际上就是MVP加上双向绑定，他实际上是一个实现了MVP这个规则的框架，

该结构中ViewModel层代替Presenter层进行逻辑控制，他的双向绑定是通过dataBinding实现的，当View发生改变时ViewModel通知Model更新数据，Model更新数据后，ViewModel通知View更新。

在实际使用中，MVVM适合复杂的应用，尤其是频繁更新或绑定数据的应用，他的优势在于简化UI更新的工作。

在一些不那么复杂的应用中可以考虑MVP和MVVM结合使用，仅使用ViewModel代替Present层进行通知，不考虑双向绑定。


MVI模式的Android架构，主要解决了传统MVP/MVVM架构中状态管理混乱和数据流向不清晰的问题。
MVI 通过引入明确的“意图”和“状态”概念，并使用 Flow（或其他流）作为统一的数据管道，将 MVVM 中隐含的、可能分散的 UI 事件处理和状态更新逻辑变得显式化、集中化和规范化，从而增强了应用的可预测性、可测试性和可维护性。
单项数据流 **View → Intent → Model → View**

您对 MVI 的理解**基本正确**，特别是抓住了 ​**​“事件分离”​**​ 和 ​**​“统一管理”​**​ 这两个核心思想。您的理解已经触及了 MVI 的本质，但我们可以再稍微深化和系统化一下，以便更清晰地看到它与 MVVM 的区别。

您的理解可以总结为：

> MVI 通过引入明确的“意图”和“状态”概念，并使用 Flow（或其他流）作为统一的数据管道，将 MVVM 中隐含的、可能分散的 UI 事件处理和状态更新逻辑变得显式化、集中化和规范化，从而增强了应用的可预测性、可测试性和可维护性。

下面我将为您详细拆解 MVI，并与 MVVM 进行对比，以便更清晰地理解。

### MVI 的核心思想：一个更严格的“单向数据流”范式

MVI 的核心可以概括为三个基本元素和一条单向数据流：

1. ​**Model (状态)​**: 代表 UI 的状态。它是一个不可变的数据对象，包含了渲染 UI 所需的所有数据。例如，一个用户列表页面的状态可能包含 `isLoading`, `users: List<User>`, `error: String?` 等。
2. ​**View**: 和 MVVM 中一样，负责将状态渲染到屏幕上。它的核心职责是：
    - 接收一个状态对象并据此绘制 UI。
    - 将用户的输入（点击、输入文本等）转换为 ​**Intent**。
3. ​**Intent**: 代表用户的**意图**​（Intent），而不是 Android 的 `Intent` 类。它是从 View 发出的所有事件的抽象描述，例如 `LoadDataIntent`, `UserClickIntent`, `SearchIntent` 等。

​**单向数据流**​ 是 MVI 的灵魂，其流程如下：

​**View → Intent → Model → View**​

1. ​**用户操作**​：用户在 View 上执行一个操作（如点击按钮）。
2. ​**发出 Intent**​：View 将这个操作转化为一个具体的 Intent（如 `LoadDataIntent`），并发送给处理中心（通常是 ViewModel）。
3. ​**处理 Intent，生成新 State**​：处理中心接收到 Intent，根据当前的 State 和 Intent 进行业务逻辑处理（如发起网络请求）。处理结束后，会生成一个**全新的 State**​（例如从 `LoadingState` 变为 `SuccessState(data)`）。
4. ​**渲染 State**​：新的 State 通过一个 State Flow（或 LiveData）被推送给 View。View 简单地根据这个最新的 State 重新渲染自身。

### MVI 与 MVVM 的详细对比

|特性|MVVM|MVI|
|---|---|---|
|​**数据流**​|​**双向数据绑定**​ (Data Binding)。数据变化自动更新 UI，UI 输入自动更新数据。也可以是单向的，但架构本身不强制。|​**严格单向**。永远是 `View -> Intent -> Model -> View` 的循环，方向明确，易于追踪。|
|​**状态管理**​|状态通常分散在多个 Observable Field（如 `LiveData<String>`, `LiveData<Boolean>`）中。|状态被统一到一个**不可变的**​ `UiState` 数据类中。UI 在任何时刻都只是这个单一状态的映射。|
|​**UI 事件处理**​|方式多样且松散。可以通过 `LiveData` 发送事件（常用 `SingleLiveEvent` 或 `SharedFlow` 解决粘性事件问题）、由 View 直接调用 ViewModel 的方法、或使用 Data Binding。|方式统一且规范。​**所有**用户交互都被定义为 `Intent`，并作为数据流发送。|
|​**View 的角色**​|主动从 ViewModel 获取数据并监听多个数据源，有时也包含一些逻辑。|​**极其被动**。只做两件事：1. 接收 State 并渲染。2. 发送 Intent。几乎不包含任何逻辑。|
|​**可预测性**​|一般。由于数据流可能是双向和多源的，当 bug 出现时，追踪根源相对困难。|​**极高**。所有状态变化都是通过处理 Intent 产生的，数据流是单向的，就像时间旅行一样可以回溯所有状态变化。|
|​**调试与测试**​|测试 ViewModel 的各个方法，需要 Mock 多个依赖。|测试非常简单：给定一个初始 State 和一系列 Intent，断言输出的 State 流是否符合预期。|

### 一个简单的代码示例对比

​**MVVM 实现一个点击事件：​**​

kotlin

复制

```kotlin
// View
myButton.setOnClickListener {
    viewModel.loadData() // View 直接调用 ViewModel 的方法
}

// ViewModel
class MyViewModel : ViewModel() {
    private val _data = MutableLiveData<String>()
    val data: LiveData<String> = _data

    fun loadData() {
        // 发起请求...
        _data.value = "New Data"
    }
}
```

​**MVI 实现同一个点击事件：​**​

kotlin

复制

```kotlin
// View
myButton.setOnClickListener {
    viewModel.intent.send(LoadDataIntent) // View 发送一个 Intent
}

// Intent
sealed interface Intent {
    object LoadDataIntent : Intent
}

// State
data class UiState(val data: String = "", val isLoading: Boolean = false)

// ViewModel
class MyViewModel : ViewModel() {
    private val _state = MutableStateFlow(UiState())
    val state: StateFlow<UiState> = _state.asStateFlow()

    val intent = MutableSharedFlow<Intent>()

    init {
        viewModelScope.launch {
            intent.collect { intent ->
                when (intent) {
                    is LoadDataIntent -> loadData()
                }
            }
        }
    }

    private fun loadData() {
        _state.update { it.copy(isLoading = true) }
        // 发起请求...
        _state.update { it.copy(isLoading = false, data = "New Data") }
    }
}
```

### 结论

您的理解非常准确！MVI 并不是一个全新的架构，而是对 MVVM 的一种**规范和强化**。它通过引入“Intent”和“单一不可变State”的概念，并利用 Kotlin Flow 的强大能力，强制实现了**单向数据流**。

​**MVI 的优势在于：​**​

- ​**状态管理**​：单一可信数据源，避免了状态不一致的问题。
- ​**强可预测性**​：数据流清晰，易于调试和追溯状态变化。
- ​**极高的可测试性**​：业务逻辑完全集中在处理 Intent 和生成 State 的组件中。
- ​**平台无关性**​：View 极其简单和被动，使得业务逻辑更容易共享（例如与 Compose 共享 ViewModel）。

​**代价是：​**​

- ​**样板代码较多**​：需要定义 Intent 和 State 类。
- ​**学习曲线**​：需要理解响应式编程和单向数据流。

### Glide原理

Glide是一图片加载框架，相比其他图片加载框架，Glide的使用更方便，因为他是链式调用的，内存占用小，是Picasso的一半，支持gif。

它最大的优势还是三级缓存，分别是内存缓存、磁盘缓存、资源池缓存，而内存缓存是弱引用，基于lru算法，最少使用的可能会被移除。磁盘缓存，但是应用重启时缓存依旧存在，一般会有一个过期时间。资源池缓存，用于缓存处理过的bitmap图像，使用强引用，只有不再使用或内存紧张时glide才会将它移除。读取顺序是内存缓存->磁盘缓存。当我们需要加载图片时，他会依次从三个缓存中寻找，没有的花才会请求接口，缓存可以减少内存消耗以及重复的网络请求。

Glide的基本使用流程是load、with、into，load传入的是一个context，Glide生命周期和context保持一致的原理就是它在底层创建了一个不可见的fragment，并把这个fragment生命周期和context进行绑定，以此来达到生命周期同步的目的。wit有多个重载方法，这意味着它可以加载多种图片类型，但是它最后返回的值都是requestBuilder。Into传入的是一个控件，将处理后的图片显示在控件上，Glide的缓存功能就是在该方法中进行的。传入的控件会在底层封装成一个target对象，它可以获取自身绑定的请求，请求具有唯一性，新请求会清除旧请求用以保证控件复用时不会错位。


## Hilt依赖注入

依赖注入本质是一种参数传递和实例创建，强调类不应构建其依赖项的实例，而是由外部提供这些实例，这种模式能够实现关注点分离，提高可测试性、重用性和维护性。
```kotlin
@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    @Provides
    @Singleton // 关键注解
    fun provideNetworkViewModel(): RequestCollection {
        return RequestCollection(App.context) // 每次返回同一实例
    }
}
```
@`@Singleton` 注解 + `SingletonComponent` 确保全局唯一实例
与 Application 同生命周期（通过 `App.context` 绑定)

### Retrofit
用于Android与Java的类型安全的库